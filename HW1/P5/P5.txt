# Your discussion here
TEST
I collaborated with Taylor Killian and Reinier Maat on this question.

Despite ensuring co-partitioning, this still seems to be a very long process on AWS. My methodology avoids .collect() as was directed in the HW instructions, but unfortunately takes about 20 minutes to find the two distances listed below on AWS w/ 5 executors running. 

Harvard -> Kevin Bacon = 3 steps
Kevin Bacon -> Harvard = 2 steps

As for the connected components, I first have the function start with a single source and find all of that source’s neighbors and then all of those neighbors’ neighbors etc… with each iteration checking to see if any of my neighbors found are duplicates. This loop ends when there are no new neighbors found. Then, my function compares all of those characters with the original starting graph and determines if there are any unfound characters using .subtractByKey(). If so, then it randomly takes one of those unfound characters and sets that as the new origin source and starts the aforementioned loop all over again. This two-step process of looping and checking continues until every character in the graph has been accounted for. 

 